"use strict";
/*
 * Copyright (c) 2016, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const lodash_1 = require("lodash");
const chalk_1 = require("chalk");
const logger_1 = require("../lib/logger");
const messages_1 = require("../lib/messages");
const crypto_2 = require("../lib/crypto");
const connection_1 = require("../lib/connection");
const configFile_1 = require("../lib/config/configFile");
const path_1 = require("path");
const os_1 = require("os");
const _uniqid = () => {
    return crypto_1.randomBytes(16).toString('hex');
};
function getTestLocalPath(uid) {
    return Promise.resolve(path_1.join(os_1.tmpdir(), uid, 'sfdx_core', 'local'));
}
function getTestGlobalPath(uid) {
    return Promise.resolve(path_1.join(os_1.tmpdir(), uid, 'sfdx_core', 'global'));
}
async function retrieveRootPath(isGlobal, uid = _uniqid()) {
    return isGlobal ? await getTestGlobalPath(uid) : await getTestLocalPath(uid);
}
function defaultFakeConnectionRequest(request, options) {
    return Promise.resolve({ records: [] });
}
/**
 * @module testSetup
 */
/**
 * Different hooks into {@link ConfigFile} used for testing instead of doing file IO.
 * @typedef {object} TestContext
 * @property {function} readFn A function `() => Promise<ConfigContents>;` that controls
 * all aspect of {@link ConfigFile.read}. For example, it won't set the contents unless
 * explicitly done. Only use this if you know what you are doing. Use retrieveContents
 * instead.
 * @property {function} writeFn A function `() => Promise<void>;` that controls all aspects
 * of {@link ConfigFile.write}. For example, it won't read the contents unless explicitly
 * done. Only use this if you know what you are doing. Use updateContents instead.
 * @property {object} contents The contents that are used when @{link ConfigFile.read} unless
 * retrieveContents is set. This will also contain the new config when @{link ConfigFile.write}
 * is called. This will persist through config instances, such as {@link Alias.update} and
 * {@link Alias.fetch}.
 * @property {function} retrieveContents A function `() => Promise<object>;` to conditionally
 * read based on the config instance. The `this` value will be the config instance.
 * @property {function} updateContents A function `() => Promise<object>;` to conditionally
 * set based on the config instance. The `this` value will be the config instance.
 */
/**
 * Different configuration options when running before each.
 * @typedef {object} TestContext
 * @property {sinon.sandbox} SANDBOX The default sandbox is cleared out before
 * each test run. See [sinon sandbox]{@link http://sinonjs.org/releases/v1.17.7/sandbox/}.
 * @property {SandboxTypes} SANDBOXES An object of different sandboxes. Used when
 * needing to restore parts of the system for customized testing.
 * @property {Logger} TEST_LOGGER The test logger that is used when {@link Logger.child}
 * is used anywhere. It uses memory logging.
 * @property {string} id A unique id for the test run.
 * @property {function} uniqid A function `() => string` that returns unique strings.
 * @property {object} configStubs An object of `[configName: string]: ConfigStub` used in test that interact with config files.
 * names to {@link ConfigStubs} that contain properties used when reading and writing
 * to config files.
 * @property {function} localPathRetriever A function `(uid: string) => Promise<string>;`
 * used when resolving the local path.
 * @property {function} globalPathRetriever A function `(uid: string) => Promise<string>;`
 * used when resolving the global path.
 * @property {function} rootPathRetriever: A function `(isGlobal: boolean, uid?: string) => Promise<string>;`
 * used then resolving paths. Calls localPathRetriever and globalPathRetriever.
 */
/**
 * Use to mock out different pieces of sfdx-core to make testing easier. This will mock out
 * logging to a file, config file reading and writing, local and global path resolution, and
 * *http request using connection (soon)*.
 * @function testSetup
 * @returns {TestContext}
 *
 * @example
 * // In a mocha tests
 * import testSetup from 'sfdx-core/dist/test';
 *
 * const $$ = testSetup();
 *
 * describe(() => {
 *  it('test', () => {
 *    // Stub out your own method
 *    $$.SANDBOX.stub(MyClass.prototype, 'myMethod').returnsFake(() => {});
 *
 *    // Set the contents that is used when aliases are read. Same for all config files.
 *    $$.configStubs['Aliases'].content = { 'myTestAlias': 'user@company.com' };
 *
 *    // Will use the contents set above.
 *    const username = Aliases.fetch('myTestAlias');
 *    expect(username).to.equal('user@company.com');
 *  });
 * });
 */
exports.testSetup = lodash_1.once((sinon) => {
    if (!sinon) {
        try {
            sinon = require('sinon');
        }
        catch (e) {
            throw new Error('The package sinon was not found. Add it to your package.json and pass it in to testSetup(sinon.sandbox)');
        }
    }
    // Import all the messages files in the sfdx-core messages dir.
    // Messages.importMessagesDirectory(pathJoin(__dirname, '..', '..'));
    messages_1.Messages.importMessagesDirectory(path_1.join(__dirname));
    // Create a global sinon sandbox and a test logger instance for use within tests.
    const defaultSandbox = sinon.createSandbox();
    const testContext = {
        SANDBOX: defaultSandbox,
        SANDBOXES: {
            DEFAULT: defaultSandbox,
            CONFIG: sinon.createSandbox(),
            CRYPTO: sinon.createSandbox(),
            CONNECTION: sinon.createSandbox()
        },
        TEST_LOGGER: new logger_1.Logger({ name: 'SFDX_Core_Test_Logger' }).useMemoryLogging(),
        id: _uniqid(),
        uniqid: _uniqid,
        configStubs: {},
        localPathRetriever: getTestLocalPath,
        globalPathRetriever: getTestGlobalPath,
        rootPathRetriever: retrieveRootPath,
        fakeConnectionRequest: defaultFakeConnectionRequest
    };
    const chalkEnabled = chalk_1.default.enabled;
    beforeEach(() => {
        // Most core files create a child logger so stub this to return our test logger.
        testContext.SANDBOX.stub(logger_1.Logger, 'child').returns(Promise.resolve(testContext.TEST_LOGGER));
        testContext.SANDBOXES.CONFIG.stub(configFile_1.ConfigFile, 'resolveRootFolder').callsFake((isGlobal) => testContext.rootPathRetriever(isGlobal, testContext.id));
        // Mock out all config file IO for all tests. They can restore individually if they need original functionality.
        testContext.SANDBOXES.CONFIG.stub(configFile_1.ConfigFile.prototype, 'read').callsFake(async function () {
            const stub = testContext.configStubs[this.constructor.name] || {};
            if (stub.readFn) {
                return await stub.readFn.call(this);
            }
            let contents = stub.contents || {};
            if (stub.retrieveContents) {
                contents = await stub.retrieveContents.call(this);
            }
            this.setContentsFromObject(contents);
            return Promise.resolve(this.getContents());
        });
        testContext.SANDBOXES.CONFIG.stub(configFile_1.ConfigFile.prototype, 'write').callsFake(async function (newContents) {
            if (!testContext.configStubs[this.constructor.name]) {
                testContext.configStubs[this.constructor.name] = {};
            }
            const stub = testContext.configStubs[this.constructor.name];
            if (stub.writeFn) {
                return await stub.writeFn.call(this, newContents);
            }
            let contents = newContents || this.getContents();
            if (stub.updateContents) {
                contents = await stub.updateContents.call(this);
            }
            this.setContents(contents);
            testContext.configStubs[this.constructor.name].contents = this.toObject();
            return Promise.resolve();
        });
        testContext.SANDBOXES.CRYPTO.stub(crypto_2.Crypto.prototype, 'getKeyChain').callsFake(() => Promise.resolve({
            setPassword: () => Promise.resolve(),
            getPassword: (data, cb) => cb(undefined, '12345678901234567890123456789012')
        }));
        testContext.SANDBOXES.CONNECTION.stub(connection_1.Connection.prototype, 'request').callsFake(function (request, options) {
            if (request === `${this.instanceUrl}/services/data`) {
                return Promise.resolve([{ version: '42.0' }]);
            }
            return testContext.fakeConnectionRequest.call(this, request, options);
        });
        chalk_1.default.enabled = false;
    });
    afterEach(() => {
        testContext.SANDBOX.restore();
        lodash_1.forEach(testContext.SANDBOXES, (theSandbox) => theSandbox.restore());
        testContext.configStubs = {};
        chalk_1.default.enabled = chalkEnabled;
    });
    return testContext;
});
//# sourceMappingURL=testSetup.js.map