"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
/**
 * @module json
 */
const lodash_2 = require("lodash");
const sfdxError_1 = require("../sfdxError");
const fs_1 = require("./fs");
/**
 * Read a file and convert it to JSON.
 *
 * @param {string} jsonPath The path of the file.
 * @param {boolean} [throwOnEmpty] Whether to throw an error if the JSON file is empty.
 * @return {Promise<AnyJson>} The contents of the file as a JSON object.
 */
async function readJson(jsonPath, throwOnEmpty) {
    const fileData = await fs_1.readFile(jsonPath, 'utf8');
    return await parseJson(fileData, jsonPath, throwOnEmpty);
}
exports.readJson = readJson;
/**
 * Read a file and convert it to JSON, throwing an error if the parsed contents are not a `JsonMap`.
 *
 * @param {string} jsonPath The path of the file.
 * @param {boolean} [throwOnEmpty] Whether to throw an error if the JSON file is empty.
 * @return {Promise<JsonMap>} The contents of the file as a JSON object.
 */
async function readJsonMap(jsonPath, throwOnEmpty) {
    const fileData = await fs_1.readFile(jsonPath, 'utf8');
    return await parseJsonMap(fileData, jsonPath, throwOnEmpty);
}
exports.readJsonMap = readJsonMap;
/**
 * Convert a JSON-compatible object to a `string` and write it to a file.
 *
 * @param {string} jsonPath The path of the file to write.
 * @param {object} data The JSON object to write.
 * @return {Promise<void>}
 */
async function writeJson(jsonPath, data) {
    const fileData = JSON.stringify(data, null, 4);
    await fs_1.writeFile(jsonPath, fileData, { encoding: 'utf8', mode: fs_1.DEFAULT_USER_FILE_MODE });
}
exports.writeJson = writeJson;
/**
 * Parse JSON `string` data.
 *
 * @param {string} data Data to parse.
 * @param {String} [jsonPath=unknown] The file path from which the JSON was loaded.
 * @param {boolean} [throwOnEmpty=true] If the data contents are empty.
 * @returns {Promise<AnyJson>}
 * @throws {SfdxError} **`{name: 'JsonParseError'}`** If the data contents are empty.
 */
async function parseJson(data, jsonPath = 'unknown', throwOnEmpty = true) {
    if (lodash_2.isEmpty(data) && throwOnEmpty) {
        throw sfdxError_1.SfdxError.create('@salesforce/core', 'core', 'JsonParseError', [jsonPath, 1, 'FILE HAS NO CONTENT']);
    }
    try {
        return JSON.parse(data || '{}');
    }
    catch (error) {
        await processJsonError(error, data, jsonPath);
    }
}
exports.parseJson = parseJson;
/**
 * Parse JSON `string` data, expecting the result to be a `JsonMap`.
 *
 * @param {string} data Data to parse.
 * @param {String} [jsonPath=unknown] The file path from which the JSON was loaded.
 * @param {boolean} [throwOnEmpty=true] If the data contents are empty.
 * @returns {Promise<JsonMap>}
 * @throws {SfdxError} **`{name: 'JsonParseError'}`** If the data contents are empty.
 * @throws {SfdxError} **`{name: 'UnexpectedJsonFileFormat'}`** If the data contents are not a `JsonMap`.
 */
async function parseJsonMap(data, jsonPath, throwOnEmpty) {
    const json = await parseJson(data, jsonPath, throwOnEmpty);
    if (json === null || json instanceof Array || (typeof json !== 'object')) {
        throw new sfdxError_1.SfdxError('UnexpectedJsonFileFormat');
    }
    return json;
}
exports.parseJsonMap = parseJsonMap;
/**
 * Finds all elements of type `T` with a given name in a `JsonMap`.  Not suitable for use
 * with object graphs containing circular references.  The specification of an appropriate
 * type `T` that will satisfy all matching element values is the responsibility of the caller.
 *
 * @param {JsonMap} json The JSON object tree to search for elements of the given name.
 * @param {string} name The name of elements to search for.
 * @returns {T[]} An array of matching elements.
 */
function getJsonValuesByName(json, name) {
    let matches = [];
    if (json.hasOwnProperty(name)) {
        matches.push(json[name]); // Asserting T here assumes the caller knows what they are asking for
    }
    const maybeRecurse = (element) => {
        if (isJsonMap(element)) {
            matches = matches.concat(getJsonValuesByName(element, name));
        }
    };
    lodash_2.forEach(json, (value) => isJsonArray(value) ? lodash_2.forEach(value, maybeRecurse) : maybeRecurse(value));
    return matches;
}
exports.getJsonValuesByName = getJsonValuesByName;
/**
 * Tests whether any JSON value is an object.
 *
 * @param {AnyJson} json Any JSON value to test.
 * @returns {boolean}
 */
function isJsonMap(json) {
    return lodash_2.isPlainObject(json);
}
exports.isJsonMap = isJsonMap;
/**
 * Tests whether any JSON value is an array.
 *
 * @param {AnyJson} json Any JSON value to test.
 * @returns {boolean}
 */
function isJsonArray(json) {
    return lodash_2.isArray(json);
}
exports.isJsonArray = isJsonArray;
/**
 * Narrows an `AnyJson` value to a `string` if it is type compatible, or returns undefined otherwise.
 *
 * @param {AnyJson} value Any JSON value to test.
 * @returns {string}
 */
function asString(value) {
    return lodash_2.isString(value) ? value : undefined;
}
exports.asString = asString;
/**
 * Narrows an `AnyJson` value to a `number` if it is type compatible, or returns undefined otherwise.
 *
 * @param {AnyJson} value Any JSON value to test.
 * @returns {number}
 */
function asNumber(value) {
    return lodash_2.isNumber(value) ? value : undefined;
}
exports.asNumber = asNumber;
/**
 * Narrows an `AnyJson` value to a `boolean` if it is type compatible, or returns undefined otherwise.
 *
 * @param {AnyJson} value Any JSON value to test.
 * @returns {boolean}
 */
function asBoolean(value) {
    return lodash_2.isBoolean(value) ? value : undefined;
}
exports.asBoolean = asBoolean;
/**
 * Narrows an `AnyJson` value to a `JsonMap` if it is type compatible, or returns undefined otherwise.
 *
 * @param {AnyJson} value Any JSON value to test.
 * @returns {JsonMap}
 */
function asJsonMap(value) {
    return isJsonMap(value) ? value : undefined;
}
exports.asJsonMap = asJsonMap;
/**
 * Narrows an `AnyJson` value to a `JsonArray` if it is type compatible, or returns undefined otherwise.
 *
 * @param {AnyJson} value Any JSON value to test.
 * @returns {JsonArray}
 */
function asJsonArray(value) {
    return isJsonArray(value) ? value : undefined;
}
exports.asJsonArray = asJsonArray;
/**
 * Narrows an `AnyJson` value to a `string` if it is type compatible, or raise an `SfdxError` otherwise.
 *
 * @param {AnyJson} value Any JSON value to test.
 * @returns {string}
 */
function ensureString(value) {
    if (!lodash_2.isString(value)) {
        throw new sfdxError_1.SfdxError('Value is not a string');
    }
    return value;
}
exports.ensureString = ensureString;
/**
 * Narrows an `AnyJson` value to a `number` if it is type compatible, or raise an `SfdxError` otherwise.
 *
 * @param {AnyJson} value Any JSON value to test.
 * @returns {number}
 */
function ensureNumber(value) {
    if (!lodash_2.isNumber(value)) {
        throw new sfdxError_1.SfdxError('Value is not a string');
    }
    return value;
}
exports.ensureNumber = ensureNumber;
/**
 * Narrows an `AnyJson` value to a `boolean` if it is type compatible, or raise an `SfdxError` otherwise.
 *
 * @param {AnyJson} value Any JSON value to test.
 * @returns {boolean}
 */
function ensureBoolean(value) {
    if (!lodash_2.isBoolean(value)) {
        throw new sfdxError_1.SfdxError('Value is not a boolean');
    }
    return value;
}
exports.ensureBoolean = ensureBoolean;
/**
 * Narrows an `AnyJson` value to a `JsonMap` if it is type compatible, or raise an `SfdxError` otherwise.
 *
 * @param {AnyJson} value Any JSON value to test.
 * @returns {JsonMap}
 */
function ensureJsonMap(value) {
    if (!isJsonMap(value)) {
        throw new sfdxError_1.SfdxError('Value is not a JsonMap');
    }
    return value;
}
exports.ensureJsonMap = ensureJsonMap;
/**
 * Narrows an `AnyJson` value to a `JsonArray` if it is type compatible, or raise an `SfdxError` otherwise.
 *
 * @param {AnyJson} value Any JSON value to test.
 * @returns {JsonArray}
 */
function ensureJsonArray(value) {
    if (!isJsonArray(value)) {
        throw new sfdxError_1.SfdxError('Value is not a JsonArray');
    }
    return value;
}
exports.ensureJsonArray = ensureJsonArray;
/**
 * Returns the first key within the object that has an upper case first letter.
 *
 * @param {JsonMap} json The object in which to check key casing.
 * @returns {string}
 */
function findUpperCaseKeys(json) {
    let _key;
    lodash_1.findKey(json, (val, key) => {
        if (key[0] === key[0].toUpperCase()) {
            _key = key;
        }
        else if (lodash_2.isPlainObject(val)) {
            _key = this.findUpperCaseKeys(val);
        }
        return _key;
    });
    return _key;
}
exports.findUpperCaseKeys = findUpperCaseKeys;
async function processJsonError(error, data, jsonPath) {
    if (error.name === 'SyntaxError') {
        const BUFFER = 20;
        // Get the position of the error from the error message.  This is the error index
        // within the file contents as 1 long string.
        const errPosition = parseInt(error.message.match(/position (\d+)/)[1], 10);
        // Get a buffered error portion to display, highlighting the error in red
        const start = Math.max(0, (errPosition - BUFFER));
        const end = Math.min(data.length, (errPosition + BUFFER));
        const errorPortion = data.substring(start, errPosition) +
            // logger.color.bgRed(data.substring(errPosition, errPosition + 1)) +
            data.substring(errPosition + 2, end);
        // only need to count new lines before the error position
        const lineNumber = data.substring(0, errPosition).split('\n').length;
        throw sfdxError_1.SfdxError.create('@salesforce/core', 'core', 'JsonParseError', [jsonPath, lineNumber, errorPortion]);
    }
    else {
        throw error;
    }
}
//# sourceMappingURL=json.js.map