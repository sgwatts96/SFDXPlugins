"use strict";
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const sfdxError_1 = require("./sfdxError");
const ux_1 = require("./ux");
const json_1 = require("./util/json");
/**
 * Prints a JSON schema in a human-friendly format.
 */
class SchemaPrinter {
    /**
     * Constructs a new `SchemaPrinter`.
     *
     * @param {Logger} logger The logger to use when emitting the printed schema.
     * @param {JsonMap} schema The schema to print.
     */
    constructor(logger, schema) {
        this.schema = schema;
        this.lines = [];
        this.logger = logger.child('SchemaPrinter');
        if (!this.schema.properties && !this.schema.items) {
            // No need to add to messages, since this should never happen. In fact,
            // this will cause a test failure if there is a command that uses a schema
            // with no properties defined.
            throw new sfdxError_1.SfdxError('There is no purpose to print a schema with no properties or items');
        }
        const startLevel = 0;
        const add = this.addFn(startLevel);
        // For object schemas, print out the "header" and first level properties differently
        if (this.schema.properties) {
            if (typeof this.schema.description === 'string') {
                // Output the overall schema description before printing the properties
                add(this.schema.description);
                add('');
            }
            Object.keys(this.schema.properties).forEach((key) => {
                const properties = json_1.asJsonMap(this.schema.properties);
                if (!properties) {
                    return;
                }
                this.parseProperty(key, json_1.asJsonMap(properties[key]), startLevel);
                add('');
            });
        }
        else {
            this.parseProperty('schema', this.schema, startLevel);
        }
    }
    /**
     * Gets a read-only array of ready-to-display lines.
     *
     * @returns {ReadonlyArray<string>}
     */
    getLines() {
        return this.lines;
    }
    /**
     * Gets a ready-to-display line by index.
     *
     * @param {number} index The line index to get.
     * @returns {string}
     */
    getLine(index) {
        return this.lines[index];
    }
    /**
     * Prints the accumulated set of schema lines.
     */
    print() {
        this.lines.forEach((line) => this.logger.info(line));
    }
    addFn(level) {
        const indent = ' '.repeat(level * 4);
        return (line) => {
            this.lines.push(`${indent}${line}`);
        };
    }
    parseProperty(name, rawProperty, level = 0) {
        if (!rawProperty) {
            return;
        }
        const add = this.addFn(level);
        const property = new SchemaProperty(this.logger, this.schema, name, rawProperty);
        add(property.renderHeader());
        if (property.type === 'object' && property.properties) {
            Object.keys(property.properties).forEach((key) => {
                this.parseProperty(key, property.getProperty(key), level + 1);
            });
        }
        if (property.type === 'array') {
            add(`    ${property.renderArrayHeader()}`);
            if (property.items && property.items.type === 'object' && property.items.properties) {
                Object.keys(property.items.properties).forEach((key) => {
                    const items = json_1.asJsonMap(property.items);
                    if (!items) {
                        return;
                    }
                    const properties = json_1.asJsonMap(items.properties);
                    if (!properties) {
                        return;
                    }
                    this.parseProperty(key, json_1.asJsonMap(properties[key]), level + 2);
                });
            }
        }
        if (property.required) {
            add(`Required: ${property.required.join(', ')}`);
        }
    }
}
exports.SchemaPrinter = SchemaPrinter;
class SchemaProperty {
    constructor(logger, schema, name, rawProperty) {
        this.logger = logger;
        this.schema = schema;
        this.name = name;
        this.rawProperty = rawProperty;
        this.name = name;
        // Capture the referenced definition, if specified
        if (typeof this.rawProperty.$ref === 'string') {
            // Copy the referenced property while adding the original property's properties on top of that --
            // if they are defined here, they take precedence over referenced definition properties.
            this.rawProperty = Object.assign({}, resolveRef(this.schema, this.rawProperty), rawProperty);
        }
        const oneOfs = json_1.asJsonArray(this.rawProperty.oneOf);
        if (oneOfs && !this.rawProperty.type) {
            this.rawProperty.type = oneOfs.map((value) => {
                return json_1.isJsonMap(value) ? value.type || value.$ref : value;
            }).join('|');
        }
        // Handle items references
        if (json_1.isJsonMap(this.items) && this.items && this.items.$ref) {
            Object.assign(this.items, resolveRef(this.schema, this.items));
        }
    }
    renderName() {
        return ux_1.color.bold(this.name);
    }
    renderTitle() {
        return this.title ? ux_1.color.underline(this.title) : '';
    }
    renderDescription() {
        return this.description ? ux_1.color.dim(this.description) : '';
    }
    renderType() {
        return this.type ? ux_1.color.dim(this.type) : '';
    }
    renderHeader() {
        return `${this.renderName()}(${this.renderType()}) - ${this.renderTitle()}: ${this.renderDescription()}`;
    }
    renderArrayHeader() {
        if (!this.items) {
            return '';
        }
        const minItems = this.minItems ? ` - min ${this.minItems}` : '';
        const prop = new SchemaProperty(this.logger, this.schema, 'items', this.items);
        return `items(${prop.renderType()}${minItems}) - ${prop.renderTitle()}: ${prop.renderDescription()}`;
    }
    get title() {
        return json_1.asString(this.rawProperty.title);
    }
    get description() {
        return json_1.asString(this.rawProperty.description);
    }
    get type() {
        return json_1.asString(this.rawProperty.type);
    }
    get required() {
        return json_1.asJsonArray(this.rawProperty.required);
    }
    get properties() {
        return json_1.asJsonMap(this.rawProperty.properties);
    }
    get items() {
        return json_1.asJsonMap(this.rawProperty.items);
    }
    get minItems() {
        return json_1.asNumber(this.rawProperty.minItems);
    }
    getProperty(key) {
        const properties = this.getProperties();
        return json_1.asJsonMap(properties && properties[key]);
    }
    getProperties() {
        return json_1.asJsonMap(this.rawProperty.properties);
    }
}
/**
 * Get the referenced definition by following the reference path on the current schema.
 *
 * @param {JsonMap} schema The source schema containing the property containing a `$ref` field.
 * @param {JsonMap} property The property that contains the `$ref` field.
 * @returns {JsonMap}
 * @private
 */
function resolveRef(schema, property) {
    const ref = property.$ref;
    if (!ref || typeof ref !== 'string') {
        return null;
    }
    return ref.split('/').reduce((prev, key) => {
        const next = prev[key];
        return key === '#' ? schema : json_1.isJsonMap(next) ? next : {};
    }, property);
}
//# sourceMappingURL=schemaPrinter.js.map